这是一份为您量身定制的 **《热爆反应室 (Thermal Shock Reaction Chamber) 开发文档》**。

这份文档基于我们讨论的最终方案：**多方块结构**、**温差/过热双模式**、**配方锁定**、以及**1.21.1 NeoForge 的技术实现与优化**。

---

# 模组开发文档：Thermal Shock (热冲击)

**项目名称：** Thermal Shock (热冲击)
**核心机器：** Thermal Shock Reaction Chamber (热爆反应室)
**目标版本：** Minecraft 1.21.1 (NeoForge)
**核心玩法：** 空岛资源生成、热力学模拟、多方块工业。

---

## 1. 核心概念与游戏循环

### 1.1 设计理念
摒弃“筛子”的概率与枯燥，采用 **“热力学工业”**。通过对物质施加极端的物理压力（高温或温差冲击）来破坏或重组物质结构。
*   **物理交互：** 早期依赖玩家在机器内放置方块或投掷物品。
*   **去随机化：** 所有产出基于确定性配方。
*   **视觉反馈：** 强调机器运行时的粒子效果、震动与“喷射”出的产物。

### 1.2 空岛开局路线 (Progression)
1.  **获得水 [生物质干馏]：**
    *   搭建初级反应室（木制）。
    *   放入树苗/树叶。
    *   利用微热（火把）进行**过热烘干** -> 获得水。
2.  **获得岩浆 [岩石熔融]：**
    *   搭建中级反应室（石制）。
    *   放入圆石。
    *   利用高热（木炭加热器）进行**过热熔融** -> 获得岩浆。
3.  **获得矿物 [温差热爆]：**
    *   放入圆石。
    *   加热至 600°C -> 瞬间注入冷水（制造 $\Delta T$）。
    *   **BOOM！** 圆石炸裂 -> 从排气口喷出沙砾+铁粒。

---

## 2. 机制详解：热冲击模拟室

### 2.1 多方块结构规则
*   **构成：** 中空立方体。
*   **尺寸：** 最小 3x3x3 (内部1格)，最大 5x5x5 (内部3x3x3)。
*   **必要组件：**
    1.  **框架 (Casing)：** 决定耐热上限（木/石/铜/耐火砖）。
    2.  **核心控制器 (Controller)：** 位于正面，负责逻辑处理、GUI、数据存储。
    3.  **排气栅格 (Vent)：** 位于背面或侧面，产物喷射口。
    4.  **热导方块 (Thermal Conductor)：** 嵌入墙壁，用于连接被动热源（岩浆块）或主动加热器。
*   **可选组件：**
    1.  **工业交互口 (Interface)：** 用于连接漏斗/管道自动化。
    2.  **强化玻璃：** 用于观察内部。

### 2.2 热力学系统 (Thermodynamics)
系统仅使用 **温度 ($^\circ C$)** 作为核心数值。

*   **目标温度 (Target Temp)：**
    *   反应室会不断尝试接近连接的所有热源中的**最高温度**。
    *   *例：* 连接火把(200°C)和岩浆(1000°C)，目标温度为 1000°C。
*   **变温速率 (Rate)：**
    *   速率 = (热源传导力总和) / (内部物品总热容)。
    *   *机制：* 贴的热源越多，升温越快；内部塞的方块越多，升温越慢。
*   **判定逻辑：** 每个 Tick 更新一次当前温度。

### 2.3 配方与运行模式
配方数据结构包含：`输入`、`输出`、`模式`、`阈值`。

#### A. 过热模式 (Overload Mode)
*   **条件：** `Current_Temp >= Recipe_Temp`。
*   **行为：** 达到温度后，进度条前进。完成时转化物品。
*   **场景：** 烧树叶得水、烧石头得岩浆、烧沙子得玻璃。

#### B. 热冲击模式 (Shock Mode)
*   **条件：** 检测 `Temp_History` (过去20 tick的温度)。
*   **判定：** `(Max_Temp_Recent - Current_Temp) >= Shock_Threshold`。
*   **行为：** 如果在短时间内温度骤降（例如倒了水），且温差足够大，**瞬间完成**配方。
*   **场景：** 炸圆石得沙砾、炸矿粉得晶体。

### 2.4 物品输入与输出
1.  **物理放置 (T1)：** 玩家走进机器内部，右键放置方块。
2.  **物理投掷 (T1)：** 玩家按Q丢弃物品，或从顶部开口丢入实体。控制器吸附实体并锁定在内部数据中。
3.  **自动化接口 (T2)：** 漏斗连接接口，物品直接进入数据层，不渲染实体（优化）。
4.  **排气喷射：** 配方完成瞬间，产物从 **排气栅格** 中心以 `Velocity` 向量喷出，生成掉落物实体。

---

## 3. 技术实现细节 (NeoForge 1.21.1)

### 3.1 数据驱动配方 (Datapack Recipes)
使用 JSON 定义配方，支持 KubeJS/CraftTweaker 修改。

```json
// data/thermalshock/recipes/blasting/cobble_to_gravel.json
{
  "type": "thermalshock:blasting",
  "input": { "item": "minecraft:cobblestone" },
  "output": [
    { "item": "minecraft:gravel", "count": 1 },
    { "item": "minecraft:iron_nugget", "chance": 0.1 }
  ],
  "mode": "shock", // "shock" 或 "overload"
  "threshold": 500, // 需要 500度的温差 或 达到500度
  "heat_capacity": 2.0 // 该物品的热容系数，影响变温速度
}
```

### 3.2 核心类结构
*   `ReactionChamberBlock`: 核心控制器方块。
*   `ReactionChamberBlockEntity`: **核心逻辑所在**。
    *   存储 `currentTemperature` (float).
    *   存储 `inventory` (IItemHandler).
    *   存储 `multiblockState` (isValid, size, structureData).
    *   存储 `lockedRecipeId` (ResourceLocation).
*   `ThermalConductorBlock`: 纯被动方块，提供 API 让核心查询连接的热源。
*   `BlastVentBlock`: 纯被动方块，提供坐标供核心喷射物品。

### 3.3 锁定配方逻辑 (Recipe Locking)
为了防止冲突（如圆石既能熔化又能爆破）：
1.  **GUI:** 添加一个 `GhostSlot` (幻影槽)。玩家通过 JEI 拖拽或手持物品点击，设定“目标配方”。
2.  **逻辑:** `BlockEntity` 在 `tick` 中检查：
    *   如果 `LockedRecipe` 不为空：只判断当前条件是否满足该配方。
    *   如果为空：不工作（或者执行默认低级配方）。

---

## 4. 1.21.1 NeoForge 优化策略 (至关重要)

由于这是多方块且涉及大量物品处理，优化是第一优先级。

### 4.1 渲染优化 (Rendering)
**痛点：** 如果在 3x3x3 的空间里渲染 27 个圆石方块模型 + 粒子效果，FPS 会爆炸。

**优化方案：**
1.  **BER (BlockEntityRenderer) 剔除：** 只有当玩家看着反应室玻璃时才渲染内部物品。
2.  **静态化处理：**
    *   如果是“方块放置”模式：直接利用 `Level.setBlock` 在内部放置真实的方块（利用原版渲染系统），而不是用 BER 渲染假方块。核心控制器只负责检测这些方块。
    *   如果是“物品投掷”模式：不要渲染几百个掉落物。将它们吸附合并为一个漂浮的“物品堆模型”（类似这种：`x64 Cobblestone`）。
3.  **粒子限制：** 爆炸时，不要生成 1000 个粒子。只在排气口生成喷射粒子，内部生成少量烟雾。

### 4.2 逻辑优化 (Tick Logic)
**痛点：** 每 tick 扫描多方块结构和周围热源会造成 TPS 下降。

**优化方案：**
1.  **缓存结构 (Caching)：**
    *   只在 `onBlockPlaced` 或 `onNeighborChanged` 时扫描多方块结构完整性。
    *   一旦结构成型，缓存所有组件的坐标。不要每 tick 都去 `level.getBlockState`。
2.  **热源脏标记 (Dirty Flag)：**
    *   `热导方块` 侦测到周围方块变化时，通知核心控制器“热源变了”。
    *   核心控制器只有在收到通知时，才重新计算“目标温度”。平时只运行简单的插值算法 `currentTemp += (target - current) * rate`。
3.  **批处理 (Batching)：**
    *   如果内部有 64 个圆石。不要循环 64 次配方检查。
    *   检查 1 次配方 -> 计算总热容 -> 统一判定 -> 统一执行爆炸 -> 统一生成 64 个产物掉落物。

### 4.3 网络包优化 (Networking)
*   使用 NeoForge 的 `PacketDistributor`。
*   **温度同步：** 不需要每 tick 同步温度给客户端。只在 GUI 打开时，或者温度变化超过 10°C 时同步（减少带宽）。
*   **GUI 同步：** 使用 `ContainerData` (IntArray) 同步温度和进度条，这是原版最高效的方式。

---

## 5. 开发路线图 (Roadmap)

### Phase 1: 核心原型
*   实现 `ReactionChamber` 单方块逻辑（先不做多方块）。
*   实现温度升降算法。
*   实现简单的配方系统（JSON加载）。
*   实现“过热”和“热爆”两种判定。

### Phase 2: 多方块与物理交互
*   实现多方块结构扫描代码。
*   实现“内部空间”逻辑：识别内部放置的方块。
*   实现 `Vent` (排气口) 的喷射逻辑。

### Phase 3: GUI与配方锁定
*   制作 GUI 界面。
*   集成 JEI/EMI，实现配方拖拽锁定。
*   实现 `Industrial Interface` (自动化接口)。

### Phase 4: 内容填充与平衡
*   添加所有耐热外壳（木/石/铜/砖）。
*   添加热源方块传导率数据。
*   编写从开局到自动化的完整配方链 (Datagen)。

---

## 6. 特殊细节备注

*   **安全机制：** 如果机器被破坏，内部存储的温度应该瞬间释放（造成一次爆炸伤害），防止玩家偷鸡拆机器重置热量。
*   **声音设计：**
    *   升温时要有细微的金属膨胀声 (Creaking)。
    *   注水降温时要有剧烈的嘶嘶声 (Hissing)。
    *   配方完成时必须有强有力的重低音爆炸声 (Blast)。
*   **JEI 兼容：** 必须展示“所需温差”或“所需温度”，并在 JEI 界面里直观显示是“熔化”还是“爆破”。

这份文档可以作为你开发的蓝图。它涵盖了从设计哲学到底层代码优化的所有关键点。祝你的模组开发顺利！